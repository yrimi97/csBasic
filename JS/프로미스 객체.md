## 프로미스 객체

> 비동기를 간편하게 처리할 수 있는 객체

비동기는 작업이 모두 실행되기 전에 다른 작업을 수행하는 방식이다. 결과를 반환하기까지 오랜 시간이 걸리더라도 그 시간동안 다른 작업들을 수행할 수 있기 때문에 효율적이다. 허나 비동기 함수에서 나온 결과를 받아서 수행해야하는 함수가 있다면 어떻게 해야 할까?

<br>

```js
print = () => {
    const res = getData();
    console.log(res);
}

getData = () => {
    
    setTimeout(() => {
        const data = {};
        data.name = "jenny";
        data.age = 12;
        
        return data;
    }, 2000);
}

print();
```
<br>

이 코드를 살펴보면 getData() 함수가 비동기적으로 처리가 되고 있어 res에 값을 할당하기 전에 다음 코드 `console.log(res);`가 실행된다. 그렇기에 undefined라는 값이 출력되는 것이다.

<br>

순차적으로 코드를 실행시키기 위해서는 콜백함수를 활용해볼 수 있다. 

``` js
print = (callback) => {
  callback();
}

getData = () => {
    
    setTimeout(() => {
        const data = {};
        data.name = "jenny";
        data.age = 12;
        
        console.log(data);
    }, 2000);
}

print(getData);
console.log("동기 처리");
```

이와같이 코드를 작성하면 우선 "동기처리"라는 문자열이 출력되고 2초 뒤에 data 객체가 출력되는 것을 확인할 수 있다.

<br>


비동기 함수에서 받은 결과로 다른 작업을 수행해야 하는 경우에 promise 객체를 사용하면 쉽게 구현이 가능하다.
<br>

물론 콜백함수를 사용해서도 순차적으로 코드가 실행되도록 

* 콜백함수는 다른 함수의 파라미터로 전달되는 함수로 비동기 작업이 완료되고 호출된다.

- `executor` : promise 생성자에 반드시 들어가야하는 함수로 작업을 비동기로 처리한다
- `resolve` `reject` : js에서 제공하는 콜백함수
    - 비동기 처리가 성공하면 resolve 실패하면 reject 콜백함수를 호출하게 된다
    - 둘 중에 하나는 반드시 호출해야 한다
- `state` `result` : promise 객체가 갖고있는 자체 property들로 `state = pending` `result = undefined`를 초기값으로 갖는다
    - `resolve(value)`가 호출되는 경우 `state = fulfilled` `result = value` 가 된다
    - `reject(error)`가 호출되는 경우 `state = rejected` `result = error` 가 된다
    - 한 번 값이 변경되면 더 이상 변경되지 않는다. 이후에 resolve나 reject 함수를 재호출되더라도 무시된다

<br><br>

**성공**



```js
const executor = (resolve, reject) => {
    setTimeout(()=>{
        resolve("성공");
    },3000)
}

const promise = new Promise(executor);
promise.then((res) => {
    console.log(res);
})
```

<br><br>

**실패**

```js
const executor = (resolve, reject) => {
    setTimeout(()=>{
        resolve("성공");
    },3000)
}

const promise = new Promise(executor);
promise.then((res) => {
    console.log(res);
})
```

